<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>五子棋 AI MASTER+ 终局杀</title>
<style>
body {
  margin:0;
  display:flex;
  justify-content:center;
  align-items:center;
  height:100vh;
  background:#f4efe3;
  font-family: "Microsoft YaHei";
}
.wrap {
  width:min(92vw,620px);
}
canvas {
  width:100%;
  aspect-ratio:1;
  background:linear-gradient(#e9c88f,#dfba7a);
  border-radius:12px;
  touch-action:none;
}
button {
  margin-top:10px;
  padding:8px 12px;
  border:none;
  background:#825e38;
  color:#fff;
  border-radius:8px;
}
h3 {
  margin:0 0 8px 0;
}
</style>
</head>
<body>
<div class="wrap">
  <h3 id="status">当前：黑棋</h3>
  <canvas id="board"></canvas>
  <button onclick="init()">重新开始</button>
</div>

<script>
/* ===================== 基础 ===================== */
const SIZE = 15;
const AI = 2;
const canvas = document.getElementById("board");
const ctx = canvas.getContext("2d");
const statusEl = document.getElementById("status");
let board=[], current=1, cell, offset, gameOver=false;

/* ===================== 初始化 ===================== */
function init(){
  board=Array.from({length:SIZE},()=>Array(SIZE).fill(0));
  current=1;
  gameOver=false;
  resizeBoard();
  updateStatus();
}
function resizeBoard(){
  const dpr=window.devicePixelRatio||1;
  const side=canvas.clientWidth;
  canvas.width=side*dpr;
  canvas.height=side*dpr;
  ctx.setTransform(dpr,0,0,dpr,0,0);
  cell=side/(SIZE+1);
  offset=cell;
  draw();
}

/* ===================== 绘制 ===================== */
function draw(){
  const side=canvas.clientWidth;
  ctx.clearRect(0,0,side,side);
  ctx.strokeStyle="#6e4e2f";
  for(let i=0;i<SIZE;i++){
    const p=offset+i*cell;
    ctx.beginPath();ctx.moveTo(offset,p);ctx.lineTo(offset+(SIZE-1)*cell,p);ctx.stroke();
    ctx.beginPath();ctx.moveTo(p,offset);ctx.lineTo(p,offset+(SIZE-1)*cell);ctx.stroke();
  }
  for(let r=0;r<SIZE;r++)
    for(let c=0;c<SIZE;c++)
      if(board[r][c]) drawStone(r,c,board[r][c]);
}
function drawStone(r,c,who){
  const x=offset+c*cell, y=offset+r*cell, radius=cell*0.42;
  const g=ctx.createRadialGradient(x-5,y-5,3,x,y,radius);
  if(who===1){g.addColorStop(0,"#666");g.addColorStop(1,"#111");}
  else {g.addColorStop(0,"#fff");g.addColorStop(1,"#ccc");}
  ctx.beginPath();ctx.arc(x,y,radius,0,Math.PI*2);ctx.fillStyle=g;ctx.fill();
}

/* ===================== 工具 ===================== */
function updateStatus(msg){statusEl.textContent=msg?msg:`当前：${current===1?"黑棋":"白棋(AI)"}`;}
function inside(r,c){return r>=0&&r<SIZE&&c>=0&&c<SIZE;}
function countLine(r,c,dr,dc,who){
  let n=0;
  while(inside(r,c)&&board[r][c]===who){n++; r+=dr; c+=dc;}
  return n;
}
function isFour(r,c,who){
  const dirs=[[1,0],[0,1],[1,1],[1,-1]];
  for(const [dR,dC] of dirs){
    const total=1+countLine(r+dR,c+dC,dR,dC,who)+countLine(r-dR,c-dC,-dR,-dC,who);
    if(total>=4) return true;
  }
  return false;
}

/* ===================== 胜负判断 ===================== */
function checkWin(r,c,who){
  const dirs=[[1,0],[0,1],[1,1],[1,-1]];
  for(const [dr,dc] of dirs){
    let count=1+scan(r,c,dr,dc,who)+scan(r,c,-dr,-dc,who);
    if(count>=5) return true;
  }
  return false;
}
function scan(r,c,dr,dc,who){
  let n=0; r+=dr;c+=dc;
  while(inside(r,c)&&board[r][c]===who){n++; r+=dr;c+=dc;}
  return n;
}

/* ===================== 落子 ===================== */
function placeStone(r,c){
  if(gameOver||board[r][c]) return;
  board[r][c]=current; draw();
  if(checkWin(r,c,current)){gameOver=true;updateStatus((current===1?"黑棋":"白棋")+"胜利");return;}
  current=current===1?2:1; updateStatus();
  if(current===AI&&!gameOver) setTimeout(aiMove,50);
}

/* ===================== 候选点生成 ===================== */
function generateCandidates(){
  const set=new Set();
  for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++) if(board[r][c])
    for(let dr=-2;dr<=2;dr++) for(let dc=-2;dc<=2;dc++){
      let nr=r+dr,nc=c+dc;
      if(inside(nr,nc)&&!board[nr][nc]) set.add(nr+","+nc);
    }
  if(set.size===0) return [{r:7,c:7}];
  return [...set].map(s=>{const[a,b]=s.split(",").map(Number);return {r:a,c:b};}).slice(0,12);
}

/* ===================== 高手棋型评分 ===================== */
function evaluatePoint(r,c,who){
  const dirs=[[1,0],[0,1],[1,1],[1,-1]];
  let total=0;
  for(const [dr,dc] of dirs){
    let count=1, openEnds=0;
    // 正方向
    let i=1; while(inside(r+dr*i,c+dc*i)&&board[r+dr*i][c+dc*i]===who){count++;i++;}
    if(inside(r+dr*i,c+dc*i)&&board[r+dr*i][c+dc*i]===0) openEnds++;
    // 反方向
    i=1; while(inside(r-dr*i,c-dc*i)&&board[r-dr*i][c-dc*i]===who){count++;i++;}
    if(inside(r-dr*i,c-dc*i)&&board[r-dr*i][c-dc*i]===0) openEnds++;
    total+=patternScore(count,openEnds);
  }
  return total;
}
function patternScore(count,open){
  if(count>=5) return 10000000;
  if(count===4&&open===2) return 1000000;
  if(count===4&&open===1) return 100000;
  if(count===3&&open===2) return 10000;
  if(count===3&&open===1) return 1000;
  if(count===2&&open===2) return 500;
  if(count===2&&open===1) return 50;
  return 10;
}
function evaluateBoard(){
  let score=0;
  for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++){
    if(board[r][c]===AI) score+=evaluatePoint(r,c,AI);
    else if(board[r][c]===1) score-=evaluatePoint(r,c,1);
  }
  return score;
}

/* ===================== 终局杀 VCF ===================== */
function findKillMoves(who){
  const moves=generateCandidates();
  const result=[];
  for(const m of moves){
    board[m.r][m.c]=who;
    if(isFour(m.r,m.c,who)) result.push(m);
    board[m.r][m.c]=0;
  }
  return result;
}
function vcfSearch(depth, attacker){
  if(depth<=0) return false;
  const kills=findKillMoves(attacker);
  for(const m of kills){
    board[m.r][m.c]=attacker;
    if(checkWin(m.r,m.c,attacker)){board[m.r][m.c]=0; return m;}
    const defend=findKillMoves(3-attacker);
    let escape=false;
    for(const d of defend){
      board[d.r][d.c]=3-attacker;
      if(!vcfSearch(depth-1,attacker)) escape=true;
      board[d.r][d.c]=0;
    }
    board[m.r][m.c]=0;
    if(!escape) return m;
  }
  return false;
}

/* ===================== AI 行动 ===================== */
function minimax(depth,isMax,alpha,beta){
  if(depth===0) return evaluateBoard();
  const moves=generateCandidates();
  if(isMax){
    let max=-Infinity;
    for(const m of moves){
      board[m.r][m.c]=AI;
      let val=minimax(depth-1,false,alpha,beta);
      board[m.r][m.c]=0;
      max=Math.max(max,val);
      alpha=Math.max(alpha,val);
      if(beta<=alpha) break;
    }
    return max;
  }else{
    let min=Infinity;
    for(const m of moves){
      board[m.r][m.c]=1;
      let val=minimax(depth-1,true,alpha,beta);
      board[m.r][m.c]=0;
      min=Math.min(min,val);
      beta=Math.min(beta,val);
      if(beta<=alpha) break;
    }
    return min;
  }
}
function aiMove(){
  // ✅ 终局杀优先
  let killMove=vcfSearch(6,AI);
  if(killMove){placeStone(killMove.r,killMove.c); return;}
  // 否则普通 MASTER+ 搜索
  let best=-Infinity, bestMove=null;
  const moves=generateCandidates().sort((a,b)=>evaluatePoint(b.r,b.c,AI)-evaluatePoint(a.r,a.c,AI)).slice(0,8);
  for(const m of moves){
    board[m.r][m.c]=AI;
    const score=minimax(2,false,-Infinity,Infinity);
    board[m.r][m.c]=0;
    if(score>best){best=score; bestMove=m;}
  }
  if(bestMove) placeStone(bestMove.r,bestMove.c);
}

/* ===================== 事件 ===================== */
canvas.addEventListener("click", e=>{
  if(current!==1) return;
  const rect=canvas.getBoundingClientRect();
  const x=e.clientX-rect.left, y=e.clientY-rect.top;
  const c=Math.round((x-offset)/cell), r=Math.round((y-offset)/cell);
  if(inside(r,c)) placeStone(r,c);
});
window.addEventListener("resize", resizeBoard);

/* ===================== 启动 ===================== */
init();
</script>
</body>
</html>
