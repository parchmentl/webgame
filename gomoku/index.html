<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>五子棋</title>
<style>
:root {
  --bg: #f4efe3;
  --panel: #ffffff;
  --text: #2b2b2b;
  --accent: #825e38;
}
* { box-sizing: border-box; }
body {
  margin: 0;
  min-height: 100vh;
  display: flex;
  align-items: center;
  justify-content: center;
  background: radial-gradient(circle at top, #fbf7ef 0%, var(--bg) 60%);
  font-family: "Microsoft YaHei", "PingFang SC", sans-serif;
  color: var(--text);
}
.wrap {
  width: min(92vw, 620px);
  max-height: 95vh;
  background: var(--panel);
  border-radius: 16px;
  box-shadow: 0 14px 34px rgba(0,0,0,0.12);
  padding: 16px;
  display: flex;
  flex-direction: column;
  align-items: center;
}
.head {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 12px;
  margin-bottom: 12px;
  width: 100%;
}
h1 { margin: 0; font-size: 22px; }
#status { font-size: 15px; color: #5f5f5f; }
.actions { display: flex; gap: 8px; }
button {
  border: none;
  border-radius: 10px;
  padding: 8px 12px;
  background: var(--accent);
  color: #fff;
  cursor: pointer;
  font-size: 14px;
}
button:active { transform: translateY(1px); }
.board {
  width: 100%;
  aspect-ratio: 1 / 1;
  border-radius: 12px;
  overflow: hidden;
}
canvas {
  width: 100%;
  height: 100%;
  display: block;
  background: linear-gradient(180deg, #e9c88f 0%, #dfba7a 100%);
  touch-action: none;
  border-radius: 12px;
}
.tip {
  margin-top: 10px;
  font-size: 13px;
  color: #666;
}
</style>
</head>
<body>
<div class="wrap">
  <div class="head">
    <div>
      <h1>五子棋</h1>
      <div id="status">当前：黑棋</div>
    </div>
    <div class="actions">
      <button id="reset">重新开始</button>
    </div>
  </div>
  <div class="board"><canvas id="board"></canvas></div>
  <div class="tip">规则：黑白轮流落子，先连成五子者胜。</div>
</div>

<script>
const SIZE = 15;
const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');
const statusEl = document.getElementById('status');
const resetBtn = document.getElementById('reset');

let cell = 0;
let offset = 0;
let board = [];
let current = 1; // 1 黑棋, 2 白棋
let gameOver = false;
let moves = 0;

function init() {
  board = Array.from({ length: SIZE }, () => Array(SIZE).fill(0));
  current = 1;
  gameOver = false;
  moves = 0;
  resizeBoard();
  updateStatus();
}

function resizeBoard() {
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  const side = Math.min(rect.width, window.innerHeight - 100);
  canvas.width = side * dpr;
  canvas.height = side * dpr;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

  cell = side / (SIZE + 1);
  offset = cell;
  draw();
}

function draw() {
  const side = canvas.clientWidth;
  ctx.clearRect(0, 0, side, side);

  // 画棋盘格
  ctx.strokeStyle = '#6e4e2f';
  ctx.lineWidth = 1;
  for (let i = 0; i < SIZE; i++) {
    const p = offset + i * cell;
    ctx.beginPath();
    ctx.moveTo(offset, p);
    ctx.lineTo(offset + (SIZE - 1) * cell, p);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(p, offset);
    ctx.lineTo(p, offset + (SIZE - 1) * cell);
    ctx.stroke();
  }

  // 画星位
  const stars = [[3,3],[3,7],[3,11],[7,3],[7,7],[7,11],[11,3],[11,7],[11,11]];
  ctx.fillStyle = '#5c3d1f';
  stars.forEach(([r,c])=>{
    ctx.beginPath();
    ctx.arc(offset + c*cell, offset + r*cell, Math.max(2, cell*0.08), 0, Math.PI*2);
    ctx.fill();
  });

  // 画棋子
  for (let r=0;r<SIZE;r++){
    for(let c=0;c<SIZE;c++){
      if(!board[r][c]) continue;
      drawStone(r,c,board[r][c]);
    }
  }
}

function drawStone(r,c,who){
  const x = offset + c*cell;
  const y = offset + r*cell;
  const radius = cell*0.42;
  const g = ctx.createRadialGradient(x-radius*0.35, y-radius*0.35, radius*0.2, x, y, radius);
  if(who===1){
    g.addColorStop(0,'#666');
    g.addColorStop(1,'#111');
  } else {
    g.addColorStop(0,'#fff');
    g.addColorStop(1,'#d9d9d9');
  }
  ctx.beginPath();
  ctx.arc(x,y,radius,0,Math.PI*2);
  ctx.fillStyle = g;
  ctx.fill();
}

function updateStatus(msg){
  if(msg){ statusEl.textContent = msg; return; }
  statusEl.textContent = gameOver ? '对局结束' : `当前：${current===1?'黑棋':'白棋'}`;
}

function xyToRC(clientX, clientY){
  const rect = canvas.getBoundingClientRect();
  const x = clientX - rect.left;
  const y = clientY - rect.top;
  const c = Math.round((x-offset)/cell);
  const r = Math.round((y-offset)/cell);
  if(r<0||r>=SIZE||c<0||c>=SIZE) return null;
  const px = offset + c*cell;
  const py = offset + r*cell;
  if(Math.hypot(x-px,y-py) > cell*0.45) return null;
  return {r,c};
}

function checkWin(r,c,who){
  const dirs=[[1,0],[0,1],[1,1],[1,-1]];
  for(const [dr,dc] of dirs){
    let count=1;
    count+=scan(r,c,dr,dc,who);
    count+=scan(r,c,-dr,-dc,who);
    if(count>=5) return true;
  }
  return false;
}

function scan(r,c,dr,dc,who){
  let n=0;
  let nr=r+dr,nc=c+dc;
  while(nr>=0&&nr<SIZE&&nc>=0&&nc<SIZE&&board[nr][nc]===who){
    n++; nr+=dr; nc+=dc;
  }
  return n;
}

function placeAt(clientX, clientY){
  if(gameOver) return;
  const rc=xyToRC(clientX,clientY);
  if(!rc) return;
  const {r,c}=rc;
  if(board[r][c]!==0) return;

  board[r][c]=current;
  moves++;
  draw();

  if(checkWin(r,c,current)){
    gameOver=true;
    updateStatus(`${current===1?'黑棋':'白棋'}获胜，共 ${moves} 手`);
    return;
  }
  if(moves===SIZE*SIZE){
    gameOver=true;
    updateStatus('平局');
    return;
  }

  current = current===1?2:1;
  updateStatus();
}

canvas.addEventListener('click', e=>placeAt(e.clientX,e.clientY));
canvas.addEventListener('touchend', e=>{
  const t = e.changedTouches[0];
  placeAt(t.clientX,t.clientY);
},{passive:true});

window.addEventListener('resize', resizeBoard);
resetBtn.addEventListener('click', init);

init();
</script>
</body>
</html>
